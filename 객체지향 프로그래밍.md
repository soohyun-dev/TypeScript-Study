## 객체지향 프로그래밍

### 명령 & 절차 지향 프로그래밍

- 데이터와 함수들 위주로 구성
- 전역적으로 선언된 변수에 접근 가능

- ❗하나를 수정하기 위해선 전체적인 어플리케이션의 flow를 이해해야됨.
- ❗수정시 Side Effect 발생 가능

  <br>

### 객체 지향 프로그래밍

- 객체 단위로 프로그래밍
- 객체들끼리 서로 의사소통하게 프로그래밍한다.
- 문제가 생긴 객체와 연결된 객체들만 수정하면 된다.
- 컴포넌트를 재사용, 확장성도 높음 => 생산성이 높아진다.

- object는 object의 `data`와 행동을 실행하는 `func`로 구성되어있음.
- class는 정의만 하는 템플릿
- object는 클래스의 인스턴스, 즉 클래스를 이용해 생성된 값.
  <br>

### 객체 지향 프로그래밍 원칙

- 클래스만 정의하고 object만 만든다고 객체 지향 프로그래밍인 것이 아님.

1. 캡슐화 (Encapsulation)

2. 추상화 (Abstraction)

3. 상속성 (Inheritance)

4. 다형성 (Polymorphism)

   <br>

#### 1. 캡슐화 (Encapsulation)

- object와 관련된 data(데이터 구조)와 func(데이터를 다루는 방법)를 객체가 맡은 역할을 수행하기 위해 하나로 묶는다. (===은닉화)
- 외부에서 볼 수 있게 하거나 없게 한다.
- 내부의 상태를 외부에서 설정할 수 없다.
- 외부 func를 통해서 내부의 상태를 변경시킬 수는 있다.

  <br>

#### 2. 추상화 (Abstraction)

- 외부에서 내부가 어떻게 구현되어있는지에 신경쓰지 않고 하위 클래스에 존재하는 공통적인 메서드를 interface로 정의.
- 공통의 속성이나 기능을 묶어 이름을 붙인 것

  <br>

#### 3. 상속성 (Inheritance)

- 상위 개념의 특징을 하위 개념이 물려 받는 것.
- 객체지향의 하이라이트. 상속이 없다면 객체 지향과 절차 지향의 차이가 사라지는 듯한 느낌.
- 정의한 클래스를 재사용할 수 있음. => 생산성이 높고 유지보수 하기 좋다.
- parent & child, super & sub, base & derived
- ex) DOM 요소는 상속을 이용하여 구현되어 있다.

<br>

#### 4. 다형성 (Polymorphism)

- 여러가지 형태를 가질 수 있는 성질
- 부모 클래스에서 물려받은 가상 함수를 자식 클래스 내에서 오버라이딩 되어 사용.

<다형성을 가능하게 하는 것>

- 오버라이딩 : 부모 클래스 메서드를 자식 클래스에서 재정의하는 것.
- 오버로딩 : 한 클래스에서 메서드 이름은 같지만 파라미터 개수나 자료형을 다르게 하여 서로 다르게 동작하게 하는 것.
